package main

import (
	"bufio"
	"fmt"
	"os"
	"strings"
	"text/template"
)

type wireConfigData struct {
	PackageName   string
	Imports       []string
	Providers     []string
	DevProviders  []string
	ProdProviders []string
}

// Use a text/template to generate the final wire.go.
// Minimal example:
var wireTemplate = `// Code generated by Wire. DO NOT EDIT.

//go:build wireinject
// +build wireinject

package {{.PackageName}}

import (
{{- range .Imports }}
	"{{.}}"
{{- end }}
)

// NewDev wires up the application in development mode.
func NewDev(
	v *validator.Validator,
	e *config.Env,
) *App {
	wire.Build(
{{- range .Providers }}
	{{.}},
{{- end }}
{{- range .DevProviders }}
	{{.}},
{{- end }}
	)
	return &App{}
}

// NewProd wires up the application in production mode.
func NewProd(
	v *validator.Validator,
	e *config.Env,
) *App {
	wire.Build(
{{- range .Providers }}
	{{.}},
{{- end }}
{{- range .ProdProviders }}
	{{.}},
{{- end }}
	)
	return &App{}
}
`

func main() {
	wireConfigFilename := "internal/app/restapi/wire_config.go"     // Source
	wireOutputFilename := "internal/app/restapi/wire_config_gen.go" // Destination

	data, err := parseWireConfig(wireConfigFilename)
	if err != nil {
		panic(err)
	}

	err = generateWireFile(wireOutputFilename, data)
	if err != nil {
		panic(err)
	}

	fmt.Printf("wire: wrote %s\n", wireOutputFilename)
}

// parseWireConfig reads wire_config.go line by line
func parseWireConfig(filename string) (*wireConfigData, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	data := &wireConfigData{
		Imports:       []string{},
		Providers:     []string{},
		DevProviders:  []string{},
		ProdProviders: []string{},
	}

	scanner := bufio.NewScanner(file)

	inImportBlock := false
	inProviders := false
	inDevProviders := false
	inProdProviders := false

	// (Optional) Keep track of imports in a set to avoid duplicates
	importSet := make(map[string]bool)

	for scanner.Scan() {
		line := scanner.Text()
		line = strings.TrimSpace(line)

		// Detect package name
		if strings.HasPrefix(line, "package ") && data.PackageName == "" {
			parts := strings.Fields(line)
			if len(parts) == 2 {
				data.PackageName = parts[1]
			}
		}

		// Detect start/end of import block
		if strings.HasPrefix(line, "import (") {
			inImportBlock = true
			continue
		}
		if inImportBlock && strings.HasPrefix(line, ")") {
			inImportBlock = false
			continue
		}

		// Inside import block
		if inImportBlock {
			impLine := strings.Trim(line, `"`)
			impLine = strings.TrimSpace(impLine)
			if impLine == "" || strings.HasPrefix(impLine, "(") ||
				strings.HasPrefix(impLine, ")") {
				continue
			}
			// (Optional) de-duplicate
			if _, seen := importSet[impLine]; !seen {
				importSet[impLine] = true
				data.Imports = append(data.Imports, impLine)
			}
			continue
		}

		// Detect providers
		if strings.HasPrefix(line, "var providers = []any{") {
			inProviders = true
			continue
		}
		if inProviders && line == "}" {
			inProviders = false
			continue
		}
		if inProviders && line != "var providers = []any{" {
			trimmed := strings.TrimRight(line, ",")
			trimmed = strings.TrimSpace(trimmed)
			if trimmed != "" && trimmed != "}" {
				data.Providers = append(data.Providers, trimmed)
			}
			continue
		}

		// Detect devProviders
		if strings.HasPrefix(line, "var devProviders = []any{") {
			inDevProviders = true
			continue
		}
		if inDevProviders && line == "}" {
			inDevProviders = false
			continue
		}
		if inDevProviders && line != "var devProviders = []any{" {
			trimmed := strings.TrimRight(line, ",")
			trimmed = strings.TrimSpace(trimmed)
			if trimmed != "" && trimmed != "}" {
				data.DevProviders = append(data.DevProviders, trimmed)
			}
			continue
		}

		// Detect prodProviders
		if strings.HasPrefix(line, "var prodProviders = []any{") {
			inProdProviders = true
			continue
		}
		if inProdProviders && line == "}" {
			inProdProviders = false
			continue
		}
		if inProdProviders && line != "var prodProviders = []any{" {
			trimmed := strings.TrimRight(line, ",")
			trimmed = strings.TrimSpace(trimmed)
			if trimmed != "" && trimmed != "}" {
				data.ProdProviders = append(data.ProdProviders, trimmed)
			}
			continue
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	// If you want to guarantee certain imports (e.g., validator/config) you can do so here:
	mustHaveImports := []string{
		"github.com/danielmesquitta/api-finance-manager/internal/config",
		"github.com/danielmesquitta/api-finance-manager/internal/pkg/validator",
	}
	for _, imp := range mustHaveImports {
		if _, seen := importSet[imp]; !seen {
			importSet[imp] = true
			data.Imports = append(data.Imports, imp)
		}
	}

	return data, nil
}

func generateWireFile(outputFilename string, data *wireConfigData) error {
	tmpl, err := template.New("wire").Parse(wireTemplate)
	if err != nil {
		return err
	}

	f, err := os.Create(outputFilename)
	if err != nil {
		return err
	}
	defer f.Close()

	return tmpl.Execute(f, data)
}
